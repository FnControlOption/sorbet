method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$8: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(Funcs))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$13: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(Funcs))
    <cfgAlias>$17: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$19: T.class_of(C) = alias <C C>
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$19: T.class_of(C))
    <cfgAlias>$22: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$24: T.class_of(C) = alias <C C>
    <statTemp>$20: Sorbet::Private::Static::Void = <cfgAlias>$22: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$24: T.class_of(C))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Funcs#f {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    x: Integer = load_arg(x)
    <returnMethodTemp>$2: Integer = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Integer
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Funcs>#f {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Funcs>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Funcs>> $1><C <U <AttachedClass>>>)
      ]
    });
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Funcs#g {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    s: Symbol = load_arg(s)
    <returnMethodTemp>$2: Symbol = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Funcs>#g {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Funcs>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Funcs>> $1><C <U <AttachedClass>>>)
      ]
    });
    s: Symbol = load_arg(s)
    <returnMethodTemp>$2: Symbol = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Funcs#h {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    s: String = load_arg(s)
    <returnMethodTemp>$2: String = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Funcs>#h {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Funcs>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Funcs>> $1><C <U <AttachedClass>>>)
      ]
    });
    s: String = load_arg(s)
    <returnMethodTemp>$2: String = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Funcs>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Funcs>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Funcs>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$7: FalseClass = false
    <statTemp>$8: Symbol(:f) = :f
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Funcs), <statTemp>$7: FalseClass, <statTemp>$8: Symbol(:f))
    <selfRestore>$10: T.class_of(Funcs) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb19(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Funcs))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Funcs))
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$9, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$10
    <cfgAlias>$24: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$26: FalseClass = false
    <statTemp>$27: Symbol(:g) = :g
    <block-pre-call-temp>$28: Sorbet::Private::Static::Void = <cfgAlias>$24: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Funcs), <statTemp>$26: FalseClass, <statTemp>$27: Symbol(:g))
    <selfRestore>$29: T.class_of(Funcs) = <self>
    <unconditional>(bb3 -> bb6)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Funcs))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$16: Symbol(:x) = :x
    <cfgAlias>$18: T.class_of(Integer) = alias <C Integer>
    <statTemp>$14: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$16: Symbol(:x), <cfgAlias>$18: T.class_of(Integer))
    <cfgAlias>$20: T.class_of(Integer) = alias <C Integer>
    <blockReturnTemp>$13: T::Private::Methods::DeclBuilder = <statTemp>$14: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$20: T.class_of(Integer))
    <blockReturnTemp>$21: T.noreturn = blockreturn<sig> <blockReturnTemp>$13: T::Private::Methods::DeclBuilder
    <unconditional>(bb5 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
#  bb9(rubyBlockId=2)
bb6(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$28: Sorbet::Private::Static::Void, <selfRestore>$29: T.class_of(Funcs))
    outerLoops: 1
    <block-call>: NilClass(bb6 -> bb9)

# backedges
#  bb6(rubyBlockId=2)
bb7(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$28: Sorbet::Private::Static::Void, <selfRestore>$29: T.class_of(Funcs))
    <statTemp>$22: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$28, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$29
    <cfgAlias>$43: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$45: TrueClass = true
    <statTemp>$46: Symbol(:g) = :g
    <block-pre-call-temp>$47: Sorbet::Private::Static::Void = <cfgAlias>$43: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Funcs), <statTemp>$45: TrueClass, <statTemp>$46: Symbol(:g))
    <selfRestore>$48: T.class_of(Funcs) = <self>
    <unconditional>(bb7 -> bb10)

# backedges
#  bb6(rubyBlockId=2)
bb9(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$28: Sorbet::Private::Static::Void, <selfRestore>$29: T.class_of(Funcs))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$35: Symbol(:s) = :s
    <cfgAlias>$37: T.class_of(Symbol) = alias <C Symbol>
    <statTemp>$33: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$35: Symbol(:s), <cfgAlias>$37: T.class_of(Symbol))
    <cfgAlias>$39: T.class_of(Symbol) = alias <C Symbol>
    <blockReturnTemp>$32: T::Private::Methods::DeclBuilder = <statTemp>$33: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$39: T.class_of(Symbol))
    <blockReturnTemp>$40: T.noreturn = blockreturn<sig> <blockReturnTemp>$32: T::Private::Methods::DeclBuilder
    <unconditional>(bb9 -> bb6)

# backedges
#  bb7(rubyBlockId=0)
#  bb13(rubyBlockId=3)
bb10(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Funcs))
    outerLoops: 1
    <block-call>: NilClass(bb10 -> bb13)

# backedges
#  bb10(rubyBlockId=3)
bb11(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Funcs))
    <statTemp>$41: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$47, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$48
    <cfgAlias>$62: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$64: FalseClass = false
    <statTemp>$65: Symbol(:h) = :h
    <block-pre-call-temp>$66: Sorbet::Private::Static::Void = <cfgAlias>$62: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Funcs), <statTemp>$64: FalseClass, <statTemp>$65: Symbol(:h))
    <selfRestore>$67: T.class_of(Funcs) = <self>
    <unconditional>(bb11 -> bb14)

# backedges
#  bb10(rubyBlockId=3)
bb13(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Funcs))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$54: Symbol(:s) = :s
    <cfgAlias>$56: T.class_of(Symbol) = alias <C Symbol>
    <statTemp>$52: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$54: Symbol(:s), <cfgAlias>$56: T.class_of(Symbol))
    <cfgAlias>$58: T.class_of(Symbol) = alias <C Symbol>
    <blockReturnTemp>$51: T::Private::Methods::DeclBuilder = <statTemp>$52: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$58: T.class_of(Symbol))
    <blockReturnTemp>$59: T.noreturn = blockreturn<sig> <blockReturnTemp>$51: T::Private::Methods::DeclBuilder
    <unconditional>(bb13 -> bb10)

# backedges
#  bb11(rubyBlockId=0)
#  bb17(rubyBlockId=4)
bb14(rubyBlockId=4):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$66: Sorbet::Private::Static::Void, <selfRestore>$67: T.class_of(Funcs))
    outerLoops: 1
    <block-call>: NilClass(bb14 -> bb17)

# backedges
#  bb14(rubyBlockId=4)
bb15(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$66: Sorbet::Private::Static::Void, <selfRestore>$67: T.class_of(Funcs))
    <statTemp>$60: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$66, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$67
    <cfgAlias>$81: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$83: TrueClass = true
    <statTemp>$84: Symbol(:h) = :h
    <block-pre-call-temp>$85: Sorbet::Private::Static::Void = <cfgAlias>$81: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Funcs), <statTemp>$83: TrueClass, <statTemp>$84: Symbol(:h))
    <selfRestore>$86: T.class_of(Funcs) = <self>
    <unconditional>(bb15 -> bb18)

# backedges
#  bb14(rubyBlockId=4)
bb17(rubyBlockId=4):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$66: Sorbet::Private::Static::Void, <selfRestore>$67: T.class_of(Funcs))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$73: Symbol(:s) = :s
    <cfgAlias>$75: T.class_of(String) = alias <C String>
    <statTemp>$71: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$73: Symbol(:s), <cfgAlias>$75: T.class_of(String))
    <cfgAlias>$77: T.class_of(String) = alias <C String>
    <blockReturnTemp>$70: T::Private::Methods::DeclBuilder = <statTemp>$71: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$77: T.class_of(String))
    <blockReturnTemp>$78: T.noreturn = blockreturn<sig> <blockReturnTemp>$70: T::Private::Methods::DeclBuilder
    <unconditional>(bb17 -> bb14)

# backedges
#  bb15(rubyBlockId=0)
#  bb21(rubyBlockId=5)
bb18(rubyBlockId=5):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$85: Sorbet::Private::Static::Void, <selfRestore>$86: T.class_of(Funcs))
    outerLoops: 1
    <block-call>: NilClass(bb18 -> bb21)

# backedges
#  bb18(rubyBlockId=5)
bb19(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$85: Sorbet::Private::Static::Void, <selfRestore>$86: T.class_of(Funcs))
    <statTemp>$79: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$85, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$86
    <cfgAlias>$101: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$103: T.class_of(T) = alias <C T>
    <statTemp>$98: T.class_of(Funcs) = <self>: T.class_of(Funcs).extend(<cfgAlias>$101: T.class_of(T::Sig))
    <cfgAlias>$106: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$108: Symbol(:f) = :f
    <statTemp>$109: Symbol(:normal) = :normal
    <statTemp>$104: Symbol(:f) = <cfgAlias>$106: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Funcs), <statTemp>$108: Symbol(:f), <statTemp>$109: Symbol(:normal))
    <statTemp>$112: Symbol(:f) = :f
    <statTemp>$110: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$112: Symbol(:f))
    <cfgAlias>$115: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$117: Symbol(:f) = :f
    <statTemp>$118: Symbol(:normal) = :normal
    <statTemp>$113: Symbol(:f) = <cfgAlias>$115: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Funcs), <statTemp>$117: Symbol(:f), <statTemp>$118: Symbol(:normal))
    <cfgAlias>$123: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$125: Symbol(:g) = :g
    <statTemp>$126: Symbol(:normal) = :normal
    <statTemp>$121: Symbol(:g) = <cfgAlias>$123: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Funcs), <statTemp>$125: Symbol(:g), <statTemp>$126: Symbol(:normal))
    <statTemp>$119: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$121: Symbol(:g))
    <cfgAlias>$129: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$131: Symbol(:g) = :g
    <statTemp>$132: Symbol(:normal) = :normal
    <statTemp>$127: Symbol(:g) = <cfgAlias>$129: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Funcs), <statTemp>$131: Symbol(:g), <statTemp>$132: Symbol(:normal))
    <cfgAlias>$137: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$139: Symbol(:h) = :h
    <statTemp>$140: Symbol(:normal) = :normal
    <statTemp>$135: Symbol(:h) = <cfgAlias>$137: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Funcs), <statTemp>$139: Symbol(:h), <statTemp>$140: Symbol(:normal))
    <statTemp>$133: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$135: Symbol(:h))
    <cfgAlias>$143: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$145: Symbol(:h) = :h
    <statTemp>$146: Symbol(:normal) = :normal
    <statTemp>$141: Symbol(:h) = <cfgAlias>$143: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Funcs), <statTemp>$145: Symbol(:h), <statTemp>$146: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb19 -> bb1)

# backedges
#  bb18(rubyBlockId=5)
bb21(rubyBlockId=5):
    blockargs=(<self>: T.class_of(Funcs), <block-pre-call-temp>$85: Sorbet::Private::Static::Void, <selfRestore>$86: T.class_of(Funcs))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$92: Symbol(:s) = :s
    <cfgAlias>$94: T.class_of(String) = alias <C String>
    <statTemp>$90: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$92: Symbol(:s), <cfgAlias>$94: T.class_of(String))
    <cfgAlias>$96: T.class_of(String) = alias <C String>
    <blockReturnTemp>$89: T::Private::Methods::DeclBuilder = <statTemp>$90: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$96: T.class_of(String))
    <blockReturnTemp>$97: T.noreturn = blockreturn<sig> <blockReturnTemp>$89: T::Private::Methods::DeclBuilder
    <unconditional>(bb21 -> bb18)

}

method ::C#test_calls {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: C = cast(<self>: NilClass, C);
    <statTemp>$5: Integer(0) = 0
    <statTemp>$3: Integer = <self>: C.f(<statTemp>$5: Integer(0))
    <cfgAlias>$8: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$9: Integer(0) = 0
    <statTemp>$6: T.untyped = <cfgAlias>$8: T.class_of(Funcs).f(<statTemp>$9: Integer(0))
    <statTemp>$12: Symbol(:f) = :f
    <statTemp>$10: Symbol = <self>: C.g(<statTemp>$12: Symbol(:f))
    <cfgAlias>$15: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$16: Symbol(:f) = :f
    <statTemp>$13: Symbol = <cfgAlias>$15: T.class_of(Funcs).g(<statTemp>$16: Symbol(:f))
    <statTemp>$19: String("hello") = "hello"
    <statTemp>$17: String = <self>: C.h(<statTemp>$19: String("hello"))
    <cfgAlias>$22: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$23: String("world") = "world"
    <statTemp>$20: String = <cfgAlias>$22: T.class_of(Funcs).h(<statTemp>$23: String("world"))
    <cfgAlias>$25: T.class_of(C) = alias <C C>
    <returnMethodTemp>$2: T.untyped = <cfgAlias>$25: T.class_of(C).f()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:C>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(C) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U C>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U C>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$3: T.class_of(C) = <self>: T.class_of(C).include(<cfgAlias>$6: T.class_of(Funcs))
    <cfgAlias>$9: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$11: Symbol(:test_calls) = :test_calls
    <statTemp>$12: Symbol(:normal) = :normal
    <statTemp>$7: Symbol(:test_calls) = <cfgAlias>$9: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(C), <statTemp>$11: Symbol(:test_calls), <statTemp>$12: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

