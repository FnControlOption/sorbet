method ::Object#foo {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Object = cast(<self>: NilClass, Object);
    <arrayTemp>$5: Integer(1) = 1
    <arrayTemp>$6: Integer(2) = 2
    <magic>$7: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$4: [Integer(1), Integer(2)] = <magic>$7: T.class_of(<Magic>).<build-array>(<arrayTemp>$5: Integer(1), <arrayTemp>$6: Integer(2))
    <block-pre-call-temp>$8: Sorbet::Private::Static::Void = <statTemp>$4: [Integer(1), Integer(2)].map()
    <selfRestore>$9: Object = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb4(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb2(rubyBlockId=1):
    blockargs=(<self>: Object, <block-pre-call-temp>$8: Sorbet::Private::Static::Void, <selfRestore>$9: Object)
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$8: Sorbet::Private::Static::Void, <selfRestore>$9: Object)
    target: T::Array[T.noreturn] = Solve<<block-pre-call-temp>$8, map>
    <unconditional>(bb3 -> bb4)

# backedges
#  bb3(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb4(rubyBlockId=0):
    blockargs=(target: T.any(T::Array[T.noreturn], Integer), <selfRestore>$9: Object)
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.any(T::Array[T.noreturn], Integer) = <cfgAlias>$20: T.class_of(T).reveal_type(target: T.any(T::Array[T.noreturn], Integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.any(T::Array[T.noreturn], Integer)
    <unconditional>(bb4 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: Object, <selfRestore>$9: Object)
    outerLoops: 1
    <self>: Object = loadSelf
    <blk>$10: [Integer] = load_yield_params(map)
    <blk>$11: Integer(0) = 0
    x$1: Integer = <blk>$10: [Integer].[](<blk>$11: Integer(0))
    <returnTemp>$15: Integer = x$1
    <block-break-assign>$16: Integer = x$1
    <magic>$17: T.class_of(<Magic>) = alias <C <Magic>>
    <block-break>$18: T.untyped = <magic>$17: T.class_of(<Magic>).<block-break>(<returnTemp>$15: Integer)
    target: Integer = <block-break-assign>$16
    <unconditional>(bb5 -> bb4)

}

method ::Object#bar {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Object = cast(<self>: NilClass, Object);
    <returnMethodTemp>$2: String("foo bar") = "foo bar"
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String("foo bar")
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$7: FalseClass = false
    <statTemp>$8: Symbol(:bar) = :bar
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(<root>), <statTemp>$7: FalseClass, <statTemp>$8: Symbol(:bar))
    <selfRestore>$10: T.class_of(<root>) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb20(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(<root>))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(<root>))
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$9, sig>
    <self>: T.class_of(<root>) = <selfRestore>$10
    <cfgAlias>$33: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$35: T.class_of(T) = alias <C T>
    <statTemp>$30: T.class_of(<root>) = <self>: T.class_of(<root>).extend(<cfgAlias>$33: T.class_of(T::Sig))
    <cfgAlias>$38: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$40: Symbol(:foo) = :foo
    <statTemp>$41: Symbol(:normal) = :normal
    <statTemp>$36: Symbol(:foo) = <cfgAlias>$38: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(<root>), <statTemp>$40: Symbol(:foo), <statTemp>$41: Symbol(:normal))
    <statTemp>$44: T.untyped = <self>: T.class_of(<root>).foo()
    <statTemp>$42: NilClass = <self>: T.class_of(<root>).puts(<statTemp>$44: T.untyped)
    <cfgAlias>$48: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$50: Symbol(:bar) = :bar
    <statTemp>$51: Symbol(:normal) = :normal
    <statTemp>$46: Symbol(:bar) = <cfgAlias>$48: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(<root>), <statTemp>$50: Symbol(:bar), <statTemp>$51: Symbol(:normal))
    <block-pre-call-temp>$54: Sorbet::Private::Static::Void = <self>: T.class_of(<root>).bar()
    <selfRestore>$55: T.class_of(<root>) = <self>
    <unconditional>(bb3 -> bb6)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(<root>))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$16: Symbol(:blk) = :blk
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <statTemp>$19: T.class_of(T.proc) = <cfgAlias>$21: T.class_of(T).proc()
    <hashTemp>$22: Symbol(:x) = :x
    <cfgAlias>$24: T.class_of(Integer) = alias <C Integer>
    <statTemp>$18: T.class_of(T.proc) = <statTemp>$19: T.class_of(T.proc).params(<hashTemp>$22: Symbol(:x), <cfgAlias>$24: T.class_of(Integer))
    <cfgAlias>$26: T.class_of(String) = alias <C String>
    <hashTemp>$17: T.class_of(T.proc) = <statTemp>$18: T.class_of(T.proc).returns(<cfgAlias>$26: T.class_of(String))
    <statTemp>$14: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$16: Symbol(:blk), <hashTemp>$17: T.class_of(T.proc))
    <cfgAlias>$28: T.class_of(String) = alias <C String>
    <blockReturnTemp>$13: T::Private::Methods::DeclBuilder = <statTemp>$14: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$28: T.class_of(String))
    <blockReturnTemp>$29: T.noreturn = blockreturn<sig> <blockReturnTemp>$13: T::Private::Methods::DeclBuilder
    <unconditional>(bb5 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
#  bb11(rubyBlockId=2)
bb6(rubyBlockId=2):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$54: Sorbet::Private::Static::Void, <selfRestore>$55: T.class_of(<root>))
    outerLoops: 1
    <block-call>: NilClass(bb6 -> bb9)

# backedges
#  bb6(rubyBlockId=2)
bb7(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$54: Sorbet::Private::Static::Void, <selfRestore>$55: T.class_of(<root>))
    a: String = Solve<<block-pre-call-temp>$54, bar>
    <unconditional>(bb7 -> bb8)

# backedges
#  bb7(rubyBlockId=0)
#  bb10(rubyBlockId=2)
bb8(rubyBlockId=0):
    blockargs=(a: T.any(String, Integer), <selfRestore>$55: T.class_of(<root>))
    <self>: T.class_of(<root>) = <selfRestore>$55
    <cfgAlias>$70: T.class_of(T) = alias <C T>
    <statTemp>$68: T.any(String, Integer) = <cfgAlias>$70: T.class_of(T).reveal_type(a: T.any(String, Integer))
    <block-pre-call-temp>$74: Sorbet::Private::Static::Void = <self>: T.class_of(<root>).bar()
    <selfRestore>$75: T.class_of(<root>) = <self>
    <unconditional>(bb8 -> bb12)

# backedges
#  bb6(rubyBlockId=2)
bb9(rubyBlockId=2):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$54: Sorbet::Private::Static::Void, <selfRestore>$55: T.class_of(<root>))
    outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf
    <blk>$56: [Integer] = load_yield_params(bar)
    <blk>$57: Integer(0) = 0
    x$2: Integer = <blk>$56: [Integer].[](<blk>$57: Integer(0))
    <statTemp>$62: Integer(5) = 5
    <ifTemp>$60: T::Boolean = x$2: Integer.>(<statTemp>$62: Integer(5))
    <ifTemp>$60: T::Boolean(bb9 -> bb10)

# backedges
#  bb9(rubyBlockId=2)
bb10(rubyBlockId=2):
    blockargs=(<selfRestore>$55: T.class_of(<root>))
    outerLoops: 1
    <returnTemp>$63: Integer(10) = 10
    <block-break-assign>$64: Integer(10) = <returnTemp>$63
    <magic>$65: T.class_of(<Magic>) = alias <C <Magic>>
    <block-break>$66: T.untyped = <magic>$65: T.class_of(<Magic>).<block-break>(<returnTemp>$63: Integer(10))
    a: Integer(10) = <block-break-assign>$64
    <unconditional>(bb10 -> bb8)

# backedges
#  bb9(rubyBlockId=2)
bb11(rubyBlockId=2):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$54: Sorbet::Private::Static::Void, <selfRestore>$55: T.class_of(<root>))
    outerLoops: 1
    <blockReturnTemp>$58: String("test") = "test"
    <blockReturnTemp>$67: T.noreturn = blockreturn<bar> <blockReturnTemp>$58: String("test")
    <unconditional>(bb11 -> bb6)

# backedges
#  bb8(rubyBlockId=0)
#  bb17(rubyBlockId=3)
bb12(rubyBlockId=3):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(<root>))
    outerLoops: 1
    <block-call>: NilClass(bb12 -> bb15)

# backedges
#  bb12(rubyBlockId=3)
bb13(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(<root>))
    b: String = Solve<<block-pre-call-temp>$74, bar>
    <unconditional>(bb13 -> bb14)

# backedges
#  bb13(rubyBlockId=0)
#  bb16(rubyBlockId=3)
bb14(rubyBlockId=0):
    blockargs=(b: T.nilable(String), <selfRestore>$75: T.class_of(<root>))
    <cfgAlias>$90: T.class_of(T) = alias <C T>
    <statTemp>$88: T.nilable(String) = <cfgAlias>$90: T.class_of(T).reveal_type(b: T.nilable(String))
    <unconditional>(bb14 -> bb18)

# backedges
#  bb12(rubyBlockId=3)
bb15(rubyBlockId=3):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(<root>))
    outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf
    <blk>$76: [Integer] = load_yield_params(bar)
    <blk>$77: Integer(0) = 0
    x$3: Integer = <blk>$76: [Integer].[](<blk>$77: Integer(0))
    <statTemp>$82: Integer(5) = 5
    <ifTemp>$80: T::Boolean = x$3: Integer.>(<statTemp>$82: Integer(5))
    <ifTemp>$80: T::Boolean(bb15 -> bb16)

# backedges
#  bb15(rubyBlockId=3)
bb16(rubyBlockId=3):
    blockargs=(<selfRestore>$75: T.class_of(<root>))
    outerLoops: 1
    <block-break-assign>$84: NilClass = <returnTemp>$83
    <magic>$85: T.class_of(<Magic>) = alias <C <Magic>>
    <block-break>$86: T.untyped = <magic>$85: T.class_of(<Magic>).<block-break>(<returnTemp>$83: NilClass)
    b: NilClass = <block-break-assign>$84
    <unconditional>(bb16 -> bb14)

# backedges
#  bb15(rubyBlockId=3)
bb17(rubyBlockId=3):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(<root>))
    outerLoops: 1
    <blockReturnTemp>$78: String("test") = "test"
    <blockReturnTemp>$87: T.noreturn = blockreturn<bar> <blockReturnTemp>$78: String("test")
    <unconditional>(bb17 -> bb12)

# backedges
#  bb14(rubyBlockId=0)
#  bb21(rubyBlockId=0)
bb18(rubyBlockId=0):
    blockargs=()
    outerLoops: 1
    <statTemp>$95: Integer(1) = 1
    <statTemp>$94: String = <statTemp>$95: Integer(1).to_s()
    <statTemp>$96: String("") = ""
    <whileTemp>$93: T::Boolean = <statTemp>$94: String.==(<statTemp>$96: String(""))
    <whileTemp>$93: T::Boolean(bb18 -> bb21)

# backedges
#  bb18(rubyBlockId=0)
bb19(rubyBlockId=0):
    blockargs=()
    c: NilClass = nil
    <unconditional>(bb19 -> bb20)

# backedges
#  bb19(rubyBlockId=0)
#  bb22(rubyBlockId=0)
bb20(rubyBlockId=0):
    blockargs=(c: T.nilable(Symbol))
    <cfgAlias>$108: T.class_of(T) = alias <C T>
    <statTemp>$106: T.nilable(Symbol) = <cfgAlias>$108: T.class_of(T).reveal_type(c: T.nilable(Symbol))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb20 -> bb1)

# backedges
#  bb18(rubyBlockId=0)
bb21(rubyBlockId=0):
    blockargs=()
    outerLoops: 1
    <statTemp>$100: Integer(1) = 1
    <statTemp>$99: String = <statTemp>$100: Integer(1).to_s()
    <statTemp>$101: String("") = ""
    <ifTemp>$98: T::Boolean = <statTemp>$99: String.==(<statTemp>$101: String(""))
    <ifTemp>$98: T::Boolean(bb21 -> bb22)

# backedges
#  bb21(rubyBlockId=0)
bb22(rubyBlockId=0):
    blockargs=()
    outerLoops: 1
    <returnTemp>$102: Symbol(:abc) = :abc
    <block-break-assign>$103: Symbol(:abc) = <returnTemp>$102
    <magic>$104: T.class_of(<Magic>) = alias <C <Magic>>
    <block-break>$105: T.untyped = <magic>$104: T.class_of(<Magic>).<block-break>(<returnTemp>$102: Symbol(:abc))
    c: Symbol(:abc) = <block-break-assign>$103
    <unconditional>(bb22 -> bb20)

}

