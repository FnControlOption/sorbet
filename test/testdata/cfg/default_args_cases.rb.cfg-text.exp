method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$7: T.class_of(Test) = alias <C Test>
    <statTemp>$3: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$7: T.class_of(Test))
    <cfgAlias>$10: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$12: T.class_of(Test) = alias <C Test>
    <statTemp>$8: Sorbet::Private::Static::Void = <cfgAlias>$10: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$12: T.class_of(Test))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Test#test1 {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Test = cast(<self>: NilClass, Test);
    a: Integer = load_arg(a)
    b: Integer = load_arg(b)
    <argPresent>$3: T::Boolean = arg_present(c)
    <argPresent>$3: T::Boolean(bb0 -> bb2)

# backedges
#  bb9(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb2(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer)
    c: Integer = load_arg(c)
    <argPresent>$6: T::Boolean = arg_present(d)
    <argPresent>$6: T::Boolean(bb2 -> bb4)

# backedges
#  bb0(rubyBlockId=0)
bb3(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer)
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    c: Integer(10) = <statTemp>$4
    <unconditional>(bb3 -> bb5)

# backedges
#  bb2(rubyBlockId=0)
bb4(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer)
    d: Integer = load_arg(d)
    <unconditional>(bb4 -> bb6)

# backedges
#  bb2(rubyBlockId=0)
#  bb3(rubyBlockId=0)
bb5(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer)
    x: Integer(20) = 20
    <statTemp>$7: Integer(20) = x
    <castTemp>$8: Integer = cast(<statTemp>$7: Integer(20), Integer);
    d: Integer(20) = x
    <unconditional>(bb5 -> bb6)

# backedges
#  bb4(rubyBlockId=0)
#  bb5(rubyBlockId=0)
bb6(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer))
    e: Integer = load_arg(e)
    <argPresent>$9: T::Boolean = arg_present(f)
    <argPresent>$9: T::Boolean(bb6 -> bb7)

# backedges
#  bb6(rubyBlockId=0)
bb7(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer)
    f: String = load_arg(f)
    <unconditional>(bb7 -> bb9)

# backedges
#  bb6(rubyBlockId=0)
bb8(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer)
    <statTemp>$10: String("foo") = "foo"
    <castTemp>$11: String = cast(<statTemp>$10: String("foo"), String);
    f: String("foo") = <statTemp>$10
    <unconditional>(bb8 -> bb9)

# backedges
#  bb7(rubyBlockId=0)
#  bb8(rubyBlockId=0)
bb9(rubyBlockId=0):
    blockargs=(a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer, f: String)
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: Integer = <cfgAlias>$14: T.class_of(T).reveal_type(a: Integer)
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <statTemp>$16: Integer = <cfgAlias>$18: T.class_of(T).reveal_type(b: Integer)
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <statTemp>$20: Integer = <cfgAlias>$22: T.class_of(T).reveal_type(c: Integer)
    <cfgAlias>$26: T.class_of(T) = alias <C T>
    <statTemp>$24: Integer = <cfgAlias>$26: T.class_of(T).reveal_type(d: Integer)
    <cfgAlias>$30: T.class_of(T) = alias <C T>
    <statTemp>$28: Integer = <cfgAlias>$30: T.class_of(T).reveal_type(e: Integer)
    <cfgAlias>$34: T.class_of(T) = alias <C T>
    <statTemp>$32: String = <cfgAlias>$34: T.class_of(T).reveal_type(f: String)
    <cfgAlias>$38: T.class_of(T) = alias <C T>
    <statTemp>$36: T.proc.void = <cfgAlias>$38: T.class_of(T).reveal_type(blk: T.proc.void)
    <statTemp>$40: Sorbet::Private::Static::Void = blk: T.proc.void.call()
    <cfgAlias>$43: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.nilable(Integer) = <cfgAlias>$43: T.class_of(T).reveal_type(x: T.nilable(Integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.nilable(Integer)
    <unconditional>(bb9 -> bb1)

}

method ::Test#test2 {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Test = cast(<self>: NilClass, Test);
    <argPresent>$3: T::Boolean = arg_present(x)
    <argPresent>$3: T::Boolean(bb0 -> bb2)

# backedges
#  bb4(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb2(rubyBlockId=0):
    blockargs=()
    x: Integer = load_arg(x)
    <unconditional>(bb2 -> bb4)

# backedges
#  bb0(rubyBlockId=0)
bb3(rubyBlockId=0):
    blockargs=()
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    x: Integer(10) = <statTemp>$4
    <unconditional>(bb3 -> bb4)

# backedges
#  bb2(rubyBlockId=0)
#  bb3(rubyBlockId=0)
bb4(rubyBlockId=0):
    blockargs=(x: Integer)
    rest: T::Array[Integer] = load_arg(rest)
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$6: Integer = <cfgAlias>$8: T.class_of(T).reveal_type(x: Integer)
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: T::Array[Integer] = <cfgAlias>$12: T.class_of(T).reveal_type(rest: T::Array[Integer])
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.proc.void = <cfgAlias>$15: T.class_of(T).reveal_type(blk: T.proc.void)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.proc.void
    <unconditional>(bb4 -> bb1)

}

method ::Test#test3 {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Test = cast(<self>: NilClass, Test);
    <argPresent>$3: T::Boolean = arg_present(x)
    <argPresent>$3: T::Boolean(bb0 -> bb2)

# backedges
#  bb4(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb2(rubyBlockId=0):
    blockargs=()
    x: Integer = load_arg(x)
    <unconditional>(bb2 -> bb4)

# backedges
#  bb0(rubyBlockId=0)
bb3(rubyBlockId=0):
    blockargs=()
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    x: Integer(10) = <statTemp>$4
    <unconditional>(bb3 -> bb4)

# backedges
#  bb2(rubyBlockId=0)
#  bb3(rubyBlockId=0)
bb4(rubyBlockId=0):
    blockargs=(x: Integer)
    rest: T::Hash[Symbol, Integer] = load_arg(rest)
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$6: Integer = <cfgAlias>$8: T.class_of(T).reveal_type(x: Integer)
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: T::Hash[Symbol, Integer] = <cfgAlias>$12: T.class_of(T).reveal_type(rest: T::Hash[Symbol, Integer])
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.proc.void = <cfgAlias>$15: T.class_of(T).reveal_type(blk: T.proc.void)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.proc.void
    <unconditional>(bb4 -> bb1)

}

method ::<Class:Test>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Test) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Test>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Test>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$7: FalseClass = false
    <statTemp>$8: Symbol(:test1) = :test1
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Test), <statTemp>$7: FalseClass, <statTemp>$8: Symbol(:test1))
    <selfRestore>$10: T.class_of(Test) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb11(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Test))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Test))
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$9, sig>
    <self>: T.class_of(Test) = <selfRestore>$10
    <cfgAlias>$42: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$44: FalseClass = false
    <statTemp>$45: Symbol(:test2) = :test2
    <block-pre-call-temp>$46: Sorbet::Private::Static::Void = <cfgAlias>$42: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Test), <statTemp>$44: FalseClass, <statTemp>$45: Symbol(:test2))
    <selfRestore>$47: T.class_of(Test) = <self>
    <unconditional>(bb3 -> bb6)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Test))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$16: Symbol(:a) = :a
    <cfgAlias>$18: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$19: Symbol(:b) = :b
    <cfgAlias>$21: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$22: Symbol(:c) = :c
    <cfgAlias>$24: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$25: Symbol(:d) = :d
    <cfgAlias>$27: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$28: Symbol(:e) = :e
    <cfgAlias>$30: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$31: Symbol(:f) = :f
    <cfgAlias>$33: T.class_of(String) = alias <C String>
    <hashTemp>$34: Symbol(:blk) = :blk
    <cfgAlias>$38: T.class_of(T) = alias <C T>
    <statTemp>$36: T.class_of(T.proc) = <cfgAlias>$38: T.class_of(T).proc()
    <hashTemp>$35: T.class_of(T.proc) = <statTemp>$36: T.class_of(T.proc).void()
    <statTemp>$14: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$16: Symbol(:a), <cfgAlias>$18: T.class_of(Integer), <hashTemp>$19: Symbol(:b), <cfgAlias>$21: T.class_of(Integer), <hashTemp>$22: Symbol(:c), <cfgAlias>$24: T.class_of(Integer), <hashTemp>$25: Symbol(:d), <cfgAlias>$27: T.class_of(Integer), <hashTemp>$28: Symbol(:e), <cfgAlias>$30: T.class_of(Integer), <hashTemp>$31: Symbol(:f), <cfgAlias>$33: T.class_of(String), <hashTemp>$34: Symbol(:blk), <hashTemp>$35: T.class_of(T.proc))
    <blockReturnTemp>$13: T::Private::Methods::DeclBuilder = <statTemp>$14: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$39: T.noreturn = blockreturn<sig> <blockReturnTemp>$13: T::Private::Methods::DeclBuilder
    <unconditional>(bb5 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
#  bb9(rubyBlockId=2)
bb6(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$46: Sorbet::Private::Static::Void, <selfRestore>$47: T.class_of(Test))
    outerLoops: 1
    <block-call>: NilClass(bb6 -> bb9)

# backedges
#  bb6(rubyBlockId=2)
bb7(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$46: Sorbet::Private::Static::Void, <selfRestore>$47: T.class_of(Test))
    <statTemp>$40: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$46, sig>
    <self>: T.class_of(Test) = <selfRestore>$47
    <cfgAlias>$67: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$69: FalseClass = false
    <statTemp>$70: Symbol(:test3) = :test3
    <block-pre-call-temp>$71: Sorbet::Private::Static::Void = <cfgAlias>$67: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(Test), <statTemp>$69: FalseClass, <statTemp>$70: Symbol(:test3))
    <selfRestore>$72: T.class_of(Test) = <self>
    <unconditional>(bb7 -> bb10)

# backedges
#  bb6(rubyBlockId=2)
bb9(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$46: Sorbet::Private::Static::Void, <selfRestore>$47: T.class_of(Test))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$53: Symbol(:x) = :x
    <cfgAlias>$55: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$56: Symbol(:rest) = :rest
    <cfgAlias>$58: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$59: Symbol(:blk) = :blk
    <cfgAlias>$63: T.class_of(T) = alias <C T>
    <statTemp>$61: T.class_of(T.proc) = <cfgAlias>$63: T.class_of(T).proc()
    <hashTemp>$60: T.class_of(T.proc) = <statTemp>$61: T.class_of(T.proc).void()
    <statTemp>$51: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$53: Symbol(:x), <cfgAlias>$55: T.class_of(Integer), <hashTemp>$56: Symbol(:rest), <cfgAlias>$58: T.class_of(Integer), <hashTemp>$59: Symbol(:blk), <hashTemp>$60: T.class_of(T.proc))
    <blockReturnTemp>$50: T::Private::Methods::DeclBuilder = <statTemp>$51: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$64: T.noreturn = blockreturn<sig> <blockReturnTemp>$50: T::Private::Methods::DeclBuilder
    <unconditional>(bb9 -> bb6)

# backedges
#  bb7(rubyBlockId=0)
#  bb13(rubyBlockId=3)
bb10(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$71: Sorbet::Private::Static::Void, <selfRestore>$72: T.class_of(Test))
    outerLoops: 1
    <block-call>: NilClass(bb10 -> bb13)

# backedges
#  bb10(rubyBlockId=3)
bb11(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$71: Sorbet::Private::Static::Void, <selfRestore>$72: T.class_of(Test))
    <statTemp>$65: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$71, sig>
    <self>: T.class_of(Test) = <selfRestore>$72
    <cfgAlias>$93: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$95: T.class_of(T) = alias <C T>
    <statTemp>$90: T.class_of(Test) = <self>: T.class_of(Test).extend(<cfgAlias>$93: T.class_of(T::Sig))
    <cfgAlias>$98: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$100: Symbol(:test1) = :test1
    <statTemp>$101: Symbol(:normal) = :normal
    <statTemp>$96: Symbol(:test1) = <cfgAlias>$98: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Test), <statTemp>$100: Symbol(:test1), <statTemp>$101: Symbol(:normal))
    <cfgAlias>$104: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$106: Symbol(:test2) = :test2
    <statTemp>$107: Symbol(:normal) = :normal
    <statTemp>$102: Symbol(:test2) = <cfgAlias>$104: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Test), <statTemp>$106: Symbol(:test2), <statTemp>$107: Symbol(:normal))
    <cfgAlias>$110: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$112: Symbol(:test3) = :test3
    <statTemp>$113: Symbol(:normal) = :normal
    <statTemp>$108: Symbol(:test3) = <cfgAlias>$110: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Test), <statTemp>$112: Symbol(:test3), <statTemp>$113: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb11 -> bb1)

# backedges
#  bb10(rubyBlockId=3)
bb13(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Test), <block-pre-call-temp>$71: Sorbet::Private::Static::Void, <selfRestore>$72: T.class_of(Test))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$78: Symbol(:x) = :x
    <cfgAlias>$80: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$81: Symbol(:rest) = :rest
    <cfgAlias>$83: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$84: Symbol(:blk) = :blk
    <cfgAlias>$88: T.class_of(T) = alias <C T>
    <statTemp>$86: T.class_of(T.proc) = <cfgAlias>$88: T.class_of(T).proc()
    <hashTemp>$85: T.class_of(T.proc) = <statTemp>$86: T.class_of(T.proc).void()
    <statTemp>$76: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$78: Symbol(:x), <cfgAlias>$80: T.class_of(Integer), <hashTemp>$81: Symbol(:rest), <cfgAlias>$83: T.class_of(Integer), <hashTemp>$84: Symbol(:blk), <hashTemp>$85: T.class_of(T.proc))
    <blockReturnTemp>$75: T::Private::Methods::DeclBuilder = <statTemp>$76: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$89: T.noreturn = blockreturn<sig> <blockReturnTemp>$75: T::Private::Methods::DeclBuilder
    <unconditional>(bb13 -> bb10)

}

