method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$7: T.class_of(BlockTest) = alias <C BlockTest>
    <statTemp>$3: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$7: T.class_of(BlockTest))
    <cfgAlias>$10: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$12: T.class_of(BlockTest) = alias <C BlockTest>
    <statTemp>$8: Sorbet::Private::Static::Void = <cfgAlias>$10: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$12: T.class_of(BlockTest))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::BlockTest#blockPass {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: BlockTest = cast(<self>: NilClass, BlockTest);
    <statTemp>$4: Integer(1) = 1
    <statTemp>$5: Integer(2) = 2
    <statTemp>$6: Integer(3) = 3
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <self>: BlockTest.foo(<statTemp>$4: Integer(1), <statTemp>$5: Integer(2), <statTemp>$6: Integer(3))
    <selfRestore>$8: BlockTest = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: BlockTest, <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: BlockTest)
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: BlockTest)
    <returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$7, foo>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: BlockTest, <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: BlockTest)
    outerLoops: 1
    <self>: BlockTest = loadSelf
    <blk>$9: T.untyped = load_yield_params(foo)
    <blk>$10: Integer(0) = 0
    x$1: T.untyped = <blk>$9: T.untyped.[](<blk>$10: Integer(0))
    <blk>$10: Integer(1) = 1
    y$1: T.untyped = <blk>$9: T.untyped.[](<blk>$10: Integer(1))
    <blockReturnTemp>$11: T.untyped = x$1
    <blockReturnTemp>$12: T.noreturn = blockreturn<foo> <blockReturnTemp>$11: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:BlockTest>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(BlockTest) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U BlockTest>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U BlockTest>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:blockPass) = :blockPass
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:blockPass) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(BlockTest), <statTemp>$6: Symbol(:blockPass), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:blockPass)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

