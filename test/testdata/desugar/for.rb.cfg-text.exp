method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$8: T.class_of(A) = alias <C A>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(A))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$13: T.class_of(A) = alias <C A>
    <statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(A))
    <cfgAlias>$17: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$19: T.class_of(E) = alias <C E>
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$19: T.class_of(E))
    <cfgAlias>$22: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$24: T.class_of(E) = alias <C E>
    <statTemp>$20: Sorbet::Private::Static::Void = <cfgAlias>$22: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$24: T.class_of(E))
    <cfgAlias>$28: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$30: T.class_of(Main) = alias <C Main>
    <statTemp>$26: Sorbet::Private::Static::Void = <cfgAlias>$28: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$30: T.class_of(Main))
    <cfgAlias>$33: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$35: T.class_of(Main) = alias <C Main>
    <statTemp>$31: Sorbet::Private::Static::Void = <cfgAlias>$33: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$35: T.class_of(Main))
    <cfgAlias>$38: T.class_of(Main) = alias <C Main>
    <statTemp>$36: T.untyped = <cfgAlias>$38: T.class_of(Main).main()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:A>#each {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(A) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U A>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U A>> $1><C <U <AttachedClass>>>)
      ]
    });
    blk: T.untyped = load_arg(blk)
    <statTemp>$5: Integer(1) = 1
    <statTemp>$6: Integer(2) = 2
    <statTemp>$7: Integer(3) = 3
    <statTemp>$8: Integer(4) = 4
    <statTemp>$9: Integer(5) = 5
    <statTemp>$3: T.untyped = blk: T.untyped.call(<statTemp>$5: Integer(1), <statTemp>$6: Integer(2), <statTemp>$7: Integer(3), <statTemp>$8: Integer(4), <statTemp>$9: Integer(5))
    <statTemp>$11: Integer(6) = 6
    <statTemp>$12: Integer(7) = 7
    <statTemp>$13: Integer(8) = 8
    <statTemp>$14: Integer(9) = 9
    <statTemp>$15: Integer(0) = 0
    <returnMethodTemp>$2: T.untyped = blk: T.untyped.call(<statTemp>$11: Integer(6), <statTemp>$12: Integer(7), <statTemp>$13: Integer(8), <statTemp>$14: Integer(9), <statTemp>$15: Integer(0))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:A>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(A) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U A>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U A>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:each) = :each
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:each) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(A), <statTemp>$6: Symbol(:each), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:each)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:E>#e= {

bb0(rubyBlockId=0):
    blockargs=()
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U E>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U E>> $1><C <U <AttachedClass>>>)
      ]
    });
    e: T.untyped = load_arg(e)
    @e$3: T.untyped = e
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:E>#e {

bb0(rubyBlockId=0):
    blockargs=()
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U E>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U E>> $1><C <U <AttachedClass>>>)
      ]
    });
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:E>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(E) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U E>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U E>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$7: Symbol(:e=) = :e=
    <statTemp>$8: Symbol(:normal) = :normal
    <statTemp>$3: Symbol(:e=) = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(E), <statTemp>$7: Symbol(:e=), <statTemp>$8: Symbol(:normal))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$13: Symbol(:e) = :e
    <statTemp>$14: Symbol(:normal) = :normal
    <statTemp>$9: Symbol(:e) = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(E), <statTemp>$13: Symbol(:e), <statTemp>$14: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Main>#main {

bb0(rubyBlockId=0):
    blockargs=()
    @a$110: T.untyped = alias <C <undeclared-field-stub>> (@a)
    @@b$114: T.untyped = alias <C <undeclared-field-stub>> (@@b)
    $c$118: T.untyped = alias <C <undeclared-field-stub>> ($c)
    <self>: T.class_of(Main) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Main>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Main>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(A).each()
    <selfRestore>$7: T.class_of(Main) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb23(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    <statTemp>$3: T.untyped = Solve<<block-pre-call-temp>$6, each>
    <self>: T.class_of(Main) = <selfRestore>$7
    <cfgAlias>$17: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(A).each()
    <selfRestore>$19: T.class_of(Main) = <self>
    <unconditional>(bb3 -> bb6)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <blk>$8: T.untyped = load_yield_params(each)
    <blk>$9: Integer(0) = 0
    a$1: T.untyped = <blk>$8: T.untyped.[](<blk>$9: Integer(0))
    <statTemp>$12: T.untyped = a$1: T.untyped.inspect()
    <blockReturnTemp>$10: NilClass = <self>: T.class_of(Main).puts(<statTemp>$12: T.untyped)
    <blockReturnTemp>$14: T.noreturn = blockreturn<each> <blockReturnTemp>$10: NilClass
    <unconditional>(bb5 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
#  bb9(rubyBlockId=2)
bb6(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <block-call>: NilClass(bb6 -> bb9)

# backedges
#  bb6(rubyBlockId=2)
bb7(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    <statTemp>$15: T.untyped = Solve<<block-pre-call-temp>$18, each>
    <self>: T.class_of(Main) = <selfRestore>$19
    <cfgAlias>$43: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$44: Sorbet::Private::Static::Void = <cfgAlias>$43: T.class_of(A).each()
    <selfRestore>$45: T.class_of(Main) = <self>
    <unconditional>(bb7 -> bb10)

# backedges
#  bb6(rubyBlockId=2)
bb9(rubyBlockId=2):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <blk>$20: T.untyped = load_yield_params(each)
    forTemp$2: T.untyped = <blk>$20
    <cfgAlias>$26: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$2$2: T.untyped = <cfgAlias>$26: T.class_of(<Magic>).<splat>(forTemp$2: T.untyped)
    <cfgAlias>$30: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$32: Integer(1) = 1
    <statTemp>$33: Integer(0) = 0
    <assignTemp>$3$2: T.untyped = <cfgAlias>$30: T.class_of(<Magic>).<expand-splat>(<assignTemp>$2$2: T.untyped, <statTemp>$32: Integer(1), <statTemp>$33: Integer(0))
    <statTemp>$36: Integer(0) = 0
    a$2: T.untyped = <assignTemp>$3$2: T.untyped.[](<statTemp>$36: Integer(0))
    <statTemp>$38: T.untyped = a$2: T.untyped.inspect()
    <blockReturnTemp>$22: NilClass = <self>: T.class_of(Main).puts(<statTemp>$38: T.untyped)
    <blockReturnTemp>$40: T.noreturn = blockreturn<each> <blockReturnTemp>$22: NilClass
    <unconditional>(bb9 -> bb6)

# backedges
#  bb7(rubyBlockId=0)
#  bb13(rubyBlockId=3)
bb10(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <block-call>: NilClass(bb10 -> bb13)

# backedges
#  bb10(rubyBlockId=3)
bb11(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    <statTemp>$41: T.untyped = Solve<<block-pre-call-temp>$44, each>
    <self>: T.class_of(Main) = <selfRestore>$45
    <cfgAlias>$59: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$60: Sorbet::Private::Static::Void = <cfgAlias>$59: T.class_of(A).each()
    <selfRestore>$61: T.class_of(Main) = <self>
    <unconditional>(bb11 -> bb14)

# backedges
#  bb10(rubyBlockId=3)
bb13(rubyBlockId=3):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <blk>$46: T.untyped = load_yield_params(each)
    <blk>$47: Integer(0) = 0
    a$3: T.untyped = <blk>$46: T.untyped.[](<blk>$47: Integer(0))
    <blk>$47: Integer(1) = 1
    b$3: T.untyped = <blk>$46: T.untyped.[](<blk>$47: Integer(1))
    <statTemp>$51: T.untyped = a$3: T.untyped.inspect()
    <statTemp>$49: NilClass = <self>: T.class_of(Main).puts(<statTemp>$51: T.untyped)
    <statTemp>$54: T.untyped = b$3: T.untyped.inspect()
    <blockReturnTemp>$48: NilClass = <self>: T.class_of(Main).puts(<statTemp>$54: T.untyped)
    <blockReturnTemp>$56: T.noreturn = blockreturn<each> <blockReturnTemp>$48: NilClass
    <unconditional>(bb13 -> bb10)

# backedges
#  bb11(rubyBlockId=0)
#  bb17(rubyBlockId=4)
bb14(rubyBlockId=4):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$60: Sorbet::Private::Static::Void, <selfRestore>$61: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <block-call>: NilClass(bb14 -> bb17)

# backedges
#  bb14(rubyBlockId=4)
bb15(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$60: Sorbet::Private::Static::Void, <selfRestore>$61: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    <statTemp>$57: T.untyped = Solve<<block-pre-call-temp>$60, each>
    <self>: T.class_of(Main) = <selfRestore>$61
    <statTemp>$92: String("main") = "main"
    <statTemp>$90: NilClass = <self>: T.class_of(Main).puts(<statTemp>$92: String("main"))
    <cfgAlias>$95: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$96: Sorbet::Private::Static::Void = <cfgAlias>$95: T.class_of(A).each()
    <selfRestore>$97: T.class_of(Main) = <self>
    <unconditional>(bb15 -> bb18)

# backedges
#  bb14(rubyBlockId=4)
bb17(rubyBlockId=4):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$60: Sorbet::Private::Static::Void, <selfRestore>$61: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <blk>$62: T.untyped = load_yield_params(each)
    forTemp$4: T.untyped = <blk>$62
    <cfgAlias>$68: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$4$4: T.untyped = <cfgAlias>$68: T.class_of(<Magic>).<splat>(forTemp$4: T.untyped)
    <cfgAlias>$72: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$74: Integer(2) = 2
    <statTemp>$75: Integer(0) = 0
    <assignTemp>$5$4: T.untyped = <cfgAlias>$72: T.class_of(<Magic>).<expand-splat>(<assignTemp>$4$4: T.untyped, <statTemp>$74: Integer(2), <statTemp>$75: Integer(0))
    <statTemp>$78: Integer(0) = 0
    a$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$78: Integer(0))
    <statTemp>$81: Integer(1) = 1
    b$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$81: Integer(1))
    <statTemp>$84: T.untyped = a$4: T.untyped.inspect()
    <statTemp>$82: NilClass = <self>: T.class_of(Main).puts(<statTemp>$84: T.untyped)
    <statTemp>$87: T.untyped = b$4: T.untyped.inspect()
    <blockReturnTemp>$64: NilClass = <self>: T.class_of(Main).puts(<statTemp>$87: T.untyped)
    <blockReturnTemp>$89: T.noreturn = blockreturn<each> <blockReturnTemp>$64: NilClass
    <unconditional>(bb17 -> bb14)

# backedges
#  bb15(rubyBlockId=0)
#  bb21(rubyBlockId=5)
bb18(rubyBlockId=5):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$96: Sorbet::Private::Static::Void, <selfRestore>$97: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <block-call>: NilClass(bb18 -> bb21)

# backedges
#  bb18(rubyBlockId=5)
bb19(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$96: Sorbet::Private::Static::Void, <selfRestore>$97: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    <statTemp>$93: T.untyped = Solve<<block-pre-call-temp>$96, each>
    <self>: T.class_of(Main) = <selfRestore>$97
    <cfgAlias>$153: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$154: Sorbet::Private::Static::Void = <cfgAlias>$153: T.class_of(A).each()
    <selfRestore>$155: T.class_of(Main) = <self>
    <unconditional>(bb19 -> bb22)

# backedges
#  bb18(rubyBlockId=5)
bb21(rubyBlockId=5):
    blockargs=(<self>: T.class_of(Main), <block-pre-call-temp>$96: Sorbet::Private::Static::Void, <selfRestore>$97: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped)
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <cfgAlias>$105: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$107: Integer(5) = 5
    <statTemp>$108: Integer(0) = 0
    <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass] = <cfgAlias>$105: T.class_of(<Magic>).<expand-splat>(forTemp$6$5: NilClass, <statTemp>$107: Integer(5), <statTemp>$108: Integer(0))
    <statTemp>$112: Integer(0) = 0
    @a$110: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$112: Integer(0))
    <statTemp>$116: Integer(1) = 1
    @@b$114: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$116: Integer(1))
    <statTemp>$120: Integer(2) = 2
    $c$118: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$120: Integer(2))
    <statTemp>$123: Integer(3) = 3
    d$5: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$123: Integer(3))
    <cfgAlias>$126: T.class_of(E) = alias <C E>
    <statTemp>$129: Integer(4) = 4
    <statTemp>$127: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$129: Integer(4))
    <statTemp>$124: NilClass = <cfgAlias>$126: T.class_of(E).e=(<statTemp>$127: NilClass)
    <statTemp>$132: T.untyped = @a$110: NilClass.inspect()
    <statTemp>$130: NilClass = <self>: T.class_of(Main).puts(<statTemp>$132: T.untyped)
    <statTemp>$136: T.untyped = @@b$114: NilClass.inspect()
    <statTemp>$134: NilClass = <self>: T.class_of(Main).puts(<statTemp>$136: T.untyped)
    <statTemp>$140: T.untyped = $c$118: NilClass.inspect()
    <statTemp>$138: NilClass = <self>: T.class_of(Main).puts(<statTemp>$140: T.untyped)
    <statTemp>$144: T.untyped = d$5: NilClass.inspect()
    <statTemp>$142: NilClass = <self>: T.class_of(Main).puts(<statTemp>$144: T.untyped)
    <cfgAlias>$150: T.class_of(E) = alias <C E>
    <statTemp>$148: T.untyped = <cfgAlias>$150: T.class_of(E).e()
    <statTemp>$147: T.untyped = <statTemp>$148: T.untyped.inspect()
    <blockReturnTemp>$100: NilClass = <self>: T.class_of(Main).puts(<statTemp>$147: T.untyped)
    <blockReturnTemp>$151: T.noreturn = blockreturn<each> <blockReturnTemp>$100: NilClass
    <unconditional>(bb21 -> bb18)

# backedges
#  bb19(rubyBlockId=0)
#  bb25(rubyBlockId=6)
bb22(rubyBlockId=6):
    blockargs=(<self>: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped, <block-pre-call-temp>$154: Sorbet::Private::Static::Void, <selfRestore>$155: T.class_of(Main))
    outerLoops: 1
    <block-call>: NilClass(bb22 -> bb25)

# backedges
#  bb22(rubyBlockId=6)
bb23(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$154: Sorbet::Private::Static::Void, <selfRestore>$155: T.class_of(Main))
    <returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$154, each>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb23 -> bb1)

# backedges
#  bb22(rubyBlockId=6)
bb25(rubyBlockId=6):
    blockargs=(<self>: T.class_of(Main), @a$110: T.untyped, @@b$114: T.untyped, $c$118: T.untyped, <block-pre-call-temp>$154: Sorbet::Private::Static::Void, <selfRestore>$155: T.class_of(Main))
    outerLoops: 1
    <self>: T.class_of(Main) = loadSelf
    <blk>$156: T.untyped = load_yield_params(each)
    forTemp$6: T.untyped = <blk>$156
    <cfgAlias>$162: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$9$6: T.untyped = <cfgAlias>$162: T.class_of(<Magic>).<splat>(forTemp$6: T.untyped)
    <cfgAlias>$166: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$168: Integer(5) = 5
    <statTemp>$169: Integer(0) = 0
    <assignTemp>$10$6: T.untyped = <cfgAlias>$166: T.class_of(<Magic>).<expand-splat>(<assignTemp>$9$6: T.untyped, <statTemp>$168: Integer(5), <statTemp>$169: Integer(0))
    <statTemp>$172: Integer(0) = 0
    @a$110: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$172: Integer(0))
    <statTemp>$175: Integer(1) = 1
    @@b$114: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$175: Integer(1))
    <statTemp>$178: Integer(2) = 2
    $c$118: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$178: Integer(2))
    <statTemp>$181: Integer(3) = 3
    d$6: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$181: Integer(3))
    <cfgAlias>$184: T.class_of(E) = alias <C E>
    <statTemp>$187: Integer(4) = 4
    <statTemp>$185: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$187: Integer(4))
    <statTemp>$182: T.untyped = <cfgAlias>$184: T.class_of(E).e=(<statTemp>$185: T.untyped)
    <statTemp>$190: T.untyped = @a$110: T.untyped.inspect()
    <statTemp>$188: NilClass = <self>: T.class_of(Main).puts(<statTemp>$190: T.untyped)
    <statTemp>$194: T.untyped = @@b$114: T.untyped.inspect()
    <statTemp>$192: NilClass = <self>: T.class_of(Main).puts(<statTemp>$194: T.untyped)
    <statTemp>$198: T.untyped = $c$118: T.untyped.inspect()
    <statTemp>$196: NilClass = <self>: T.class_of(Main).puts(<statTemp>$198: T.untyped)
    <statTemp>$202: T.untyped = d$6: T.untyped.inspect()
    <statTemp>$200: NilClass = <self>: T.class_of(Main).puts(<statTemp>$202: T.untyped)
    <cfgAlias>$208: T.class_of(E) = alias <C E>
    <statTemp>$206: T.untyped = <cfgAlias>$208: T.class_of(E).e()
    <statTemp>$205: T.untyped = <statTemp>$206: T.untyped.inspect()
    <blockReturnTemp>$158: NilClass = <self>: T.class_of(Main).puts(<statTemp>$205: T.untyped)
    <blockReturnTemp>$209: T.noreturn = blockreturn<each> <blockReturnTemp>$158: NilClass
    <unconditional>(bb25 -> bb22)

}

method ::<Class:Main>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Main) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Main>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Main>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:main) = :main
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:main) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Main), <statTemp>$6: Symbol(:main), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:main)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

